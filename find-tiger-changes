#!/usr/bin/perl

use POSIX;
use XML::Parser;

$xml = 1;

if ($ARGV[0] eq '-p') {
	$xml = 0;
	shift @ARGV;
}

if ($#ARGV < 0) {
	@counties = (
		"18011", # Boone
		"18057", # Hamilton
		"18023", # Clinton
		"18159", # Tipton
	);
} else {
	@counties = @ARGV;
}

$minlat = 360;
$minlon = 360;
$maxlat = -360;
$maxlon = -360;

$pi = 4 * atan2(1, 1);
$foot = .00000274;

$matchslop = 25 * $foot;
$moveslop = 2 * $foot;
$verifyslop = 50 * $foot;

$matchslop2 = $matchslop * $matchslop;
$moveslop2 = $moveslop * $moveslop;
$verifyslop2 = $verifyslop * $verifyslop;

%county_number_map = (
	"01" => "AL", "02" => "AK", "04" => "AZ", "05" => "AR", "06" => "CA",
	"08" => "CO", "09" => "CT", "10" => "DE", "11" => "DC", "12" => "FL",
	"13" => "GA", "15" => "HI", "16" => "ID", "17" => "IL", "18" => "IN",
	"19" => "IA", "20" => "KS", "21" => "KY", "22" => "LA", "23" => "ME",
	"24" => "MD", "25" => "MA", "26" => "MI", "27" => "MN", "28" => "MS",
	"29" => "MO", "30" => "MT", "31" => "NE", "32" => "NV", "33" => "NH",
	"34" => "NJ", "35" => "NM", "36" => "NY", "37" => "NC", "38" => "ND",
	"39" => "OH", "40" => "OK", "41" => "OR", "42" => "PA", "44" => "RI",
	"45" => "SC", "46" => "SD", "47" => "TN", "48" => "TX", "49" => "UT",
	"50" => "VT", "51" => "VA", "53" => "WA", "54" => "WV", "55" => "WI",
	"56" => "WY", "60" => "AS", "66" => "GU", "69" => "MP", "72" => "PR",
	"78" => "VI",
);

unless (-f "north-america-latest.osm.pbf") {
	system "curl -O http://download.geofabrik.de/north-america-latest.osm.pbf";
}

mkdir "tiger";

%states = ();
for $county (@counties) {
	$state = substr($county, 0, 2);
	$states{$state} = 1;
}
@states = keys(%states);

open(IN, "state-bboxes");
while (<IN>) {
	chomp;
	($state, $lat1, $lon1, $lat2, $lon2) = split(/ /);
	$minlat{$state} = $lat1;
	$minlon{$state} = $lon1;
	$maxlat{$state} = $lat2;
	$maxlon{$state} = $lon2;
}

if ($#states == 0) {
	for $state (@states) {
		unless (-f "tiger/state-$state.osm.pbf") {
			print STDERR "Extract state $state\n";
			system "time ./osmconvert --out-pbf -b=$minlon{$state},$minlat{$state},$maxlon{$state},$maxlat{$state} north-america-latest.osm.pbf > tiger/state-$state.osm.pbf";
		}
	}
}

unless ($xml) {
	print "0 setlinewidth\n";
}

for $county (@counties) {
	$state = $county_number_map{substr($county, 0, 2)};
	$file = "TGR$county.ZIP";

	unless (-f "tiger/$file") {
		system "curl -o tiger/$file http://www2.census.gov/geo/tiger/tiger2006se/$state/$file";
	}

	open(IN, "unzip -p tiger/$file TGR$county.RT2 |");
	while (<IN>) {
		chomp;
		$tlid = substr($_, 5, 10);
		$tlid =~ s/^ *//;

		for ($i = 18; $i < 208; $i += 19) {
			$lon = substr($_, $i, 10) / 1000000;
			$lat = substr($_, $i + 10, 9) / 1000000;

			if ($lat != 0) {
				push @{$oldlat{$county}{$tlid}}, $lat;
				push @{$oldlon{$county}{$tlid}}, $lon;

				push @{$loctlids{"$lat$lon"}}, $tlid;
			}
		}
	}
	close(IN);

	open(IN, "unzip -p tiger/$file TGR$county.RT1 |");
	while (<IN>) {
		chomp;
		$tlid = substr($_, 5, 10);
		$tlid =~ s/^ *//;

		$startlon = substr($_, 190, 10) / 1000000;
		$startlat = substr($_, 200, 9) / 1000000;
		$endlon = substr($_, 209, 10) / 1000000;
		$endlat = substr($_, 219, 9) / 1000000;

		unshift @{$oldlat{$county}{$tlid}}, $startlat;
		unshift @{$oldlon{$county}{$tlid}}, $startlon;

		push @{$oldlat{$county}{$tlid}}, $endlat;
		push @{$oldlon{$county}{$tlid}}, $endlon;

		push @{$loctlids{"$startlat$startlon"}}, $tlid;
		push @{$loctlids{"$endlat$endlon"}}, $tlid;
	}
	close(IN);
}

for $county (@counties) {
	print STDERR "read county $county\n";

	$file = "tl_rd13_${county}_edges.zip";
	unless (-f "tiger/$file") {
		system "curl -o tiger/$file http://www2.census.gov/geo/tiger/TIGERrd13/EDGES/tl_rd13_${county}_edges.zip";
	}

	open(IN, "java shpcat tiger/$file |");
	while (<IN>) {
		chomp;

		($state, $cty, $tlid) = split(/\|/);
		$tlid =~ s/^ *//;
		next unless $tlid =~ /^[0-9]/;

		s/.*polyline //;
		@points = split(/ /, $_);

		for $p (@points) {
			($lon, $lat) = split(/,/, $p);
			push @{$newlat{$county}{$tlid}}, $lat;
			push @{$newlon{$county}{$tlid}}, $lon;

			if ($lat < $minlat) {
				$minlat = $lat;
			}
			if ($lon < $minlon) {
				$minlon = $lon;
			}
			if ($lat > $maxlat) {
				$maxlat = $lat;
			}
			if ($lon > $maxlon) {
				$maxlon = $lon;
			}
		}
	}
	close(IN);

	open(IN, "curl https://raw.github.com/ericfischer/tlid-ways/master/tlid-ways/$county |");
	while (<IN>) {
		chomp;
		($tlid, $way) = split(/ /);
		push @{$tlids{$way}}, $tlid;
	}
}

$countybounds = "$minlon,$minlat,$maxlon,$maxlat";
$rat = cos(($minlat + $maxlat) / 2 * $pi / 180);

if ($xml) {
	($sec, $min, $hour, $mday, $mon, $year) = gmtime(time);
	$timestamp = sprintf("%04d-%02d-%02dT%02d:%02d:%02dZ", $year + 1900, $mon + 1, $mday,
		$hour, $min, $sec);

	print "<osmChange version=\"0.6\" generator=\"2013 TIGER update\">\n";
} else {
	if (($maxlon - $minlon) * $rat > $maxlat - $minlat) {
		$dimension = ($maxlon - $minlon) * $rat;
	} else {
		$dimension = $maxlat - $minlat;
	}

	$lat = ($maxlat + $minlat) / 2;
	$lon = ($maxlon + $minlon) / 2;

	$minlat = $lat - $dimension / 2;
	$minlon = $lon - ($dimension / $rat / 2);
	$maxlat = $lat + $dimension / 2;
	$maxlon = $lon + ($dimension / $rat / 2);

	print "1 1 0 setrgbcolor\n";

	for $county (@counties) {
		for $tlid (keys(%{$newlat{$county}})) {
			@olat = @{$oldlat{$county}{$tlid}};

			if ($#olat < 0) {
				@a = @{$newlat{$county}{$tlid}};
				@o = @{$newlon{$county}{$tlid}};

				for ($i = 0; $i <= $#a; $i++) {
					printf("%.3f %.3f %s ",
						($o[$i] - $minlon) * 612 / ($maxlon - $minlon),
						($a[$i] - $minlat) * 612 / ($maxlat - $minlat),
						$i == 0 ? "moveto" : "lineto");
				}

				print "stroke\n";
			}
		}
	}
}

if ($#states != 0) {
	open(IN, "./osmconvert north-america-latest.osm.pbf -b=$countybounds |");
} else {
	open(IN, "./osmconvert tiger/state-$state.osm.pbf -b=$countybounds |");
}

$tmpfile = "/tmp/osm.$$";
open(OUT, ">$tmpfile");
while (<IN>) {
	print OUT;
}
close(OUT);
close(IN);

sub handle_start {
	my ($expat, $element, @tags) = @_;
	my %tags = @tags;

	if ($element eq "node") {
		$nodelat{$tags{'id'}} = $tags{'lat'};
		$nodelon{$tags{'id'}} = $tags{'lon'};
	} elsif ($element eq "way") {
		$way = $tags{'id'};
		@nodes = ();
		%newtlids = ();

		for $t (@{$tlids{$way}}) {
			$newtlids{$t} = 1;
		}
	} elsif ($element eq "nd") {
		push @nodes, $tags{'ref'};
		$noderefs{$tags{'ref'}}++;
	} elsif ($element eq "tag") {
		if ($tags{'k'} eq "tiger:tlid") {
			@tlids = split(/[ ;:]+/, $tags{'v'});
			for $t (@tlids) {
				$newtlids{$t} = 1;
			}
		}
	}
}

sub handle_end {
	my ($expat, $element) = @_;

	if ($element eq "way") {
		@{$nodes{$way}} = @nodes;
		%tl = ();

		for $t (keys(%newtlids)) {
			$tl{$t} = 1;
		}

		for $n (@nodes) {
			$lat = $nodelat{$n};
			$lon = $nodelon{$n};

			for $t (@{$loctlids{"$lat$lon"}}) {
				$tl{$t} = 1;
			}
		}

		@{$tlids{$way}} = keys(%tl);
	}
}

$parser = new XML::Parser(Handlers => { Start => \&handle_start,
					End   => \&handle_end });
$parser->parsefile($tmpfile);

# Check which nodes are already nearly in the right place according to TIGER,
# since it is safe to relocate nodes adjacent to those.

for $way (keys(%nodes)) {
	@nodes = @{$nodes{$way}};
	@tlids = @{$tlids{$way}};

	TLID:
	for $tlid (@tlids) {
		for $county (@counties) {
			@nlat = @{$newlat{$county}{$tlid}};
			@nlon = @{$newlon{$county}{$tlid}};

			for ($i = 0; $i <= $#nodes; $i++) {
				for ($j = 0; $j <= $#nlat; $j++) {
					$latd = abs($nodelat{$nodes[$i]} - $nlat[$j]);
					$lond = abs($nodelon{$nodes[$i]} - $nlon[$j]) * $rat;

					if ($latd * $latd + $lond * $lond < $verifyslop2) {
						$verified{$nodes[$i]} = 1;
						last;
					}
				}
			}
		}
	}
}

# First pass: provisional matching of endpoints.

for $way (keys(%nodes)) {
	@nodes = @{$nodes{$way}};
	@tlids = @{$tlids{$way}};

	TLID:
	for $tlid (@tlids) {
		for $county (@counties) {
			@tlat = @{$oldlat{$county}{$tlid}};
			@tlon = @{$oldlon{$county}{$tlid}};

			@nlat = @{$newlat{$county}{$tlid}};
			@nlon = @{$newlon{$county}{$tlid}};

			next if $#tlat < 1 || $#nlat < 1;

			for ($pass = 0; $pass < 2; $pass++) {
				$found = -1;
				OUTER:
				for ($i = 0; $i <= $#nodes; $i++) {
					for ($j = 0; $j <= $#tlat; $j++) {
						$latd = abs($nodelat{$nodes[$i + $j]} - $tlat[$j]);
						$lond = abs($nodelon{$nodes[$i + $j]} - $tlon[$j]) * $rat;

						next OUTER if $latd * $latd + $lond * $lond > $matchslop2;
					}

					$found = $i;
					last OUTER;
				}

				if ($found != -1) {
					for ($i = 1; $i <= $tlat - 1; $i++) {
						if ($noderefs{$nodes[$found + $i]} != 1) {
							print STDERR "Intermediate node $nodes[$found + $i] referenced by ";
							print STDERR "$noderefs{$nodes[$found + $i]} ways\n";

							next TLID;
						}
					}

					for ($i = 0; $i <= $#tlat; $i++) {
						$matched{$nodes[$found + $i]} = 1;
					}

					next TLID;
				}

				@tlat = reverse(@tlat);
				@tlon = reverse(@tlon);

				@nlat = reverse(@nlat);
				@nlon = reverse(@nlon);
			}
		}
	}
}

# Then inhibit anything that is matched but has a neighbor that is not matched or verified.

$again = 1;
while ($again) {
	$again = 0;
	for $way (keys(%nodes)) {
		@nodes = @{$nodes{$way}};

		for ($i = 1; $i <= $#nodes - 1; $i++) {
			if ($matched{$nodes[$i]}) {
				if (! (($matched{$nodes[$i - 1]} || $verified{$nodes[$i - 1]}) &&
				       ($matched{$nodes[$i + 1]} || $verified{$nodes[$i + 1]}))) {
					$matched{$nodes[$i]} = 0;
					$again = 1;

if (0) {
					print STDERR "node $nodes[$i] is inhibited: $nodelat{$nodes[$i]},$nodelon{$nodes[$i]}\n";
					print STDERR "matched is $matched{$nodes[$i]}\n";
					print STDERR "prev is $nodes[$i - 1] which is $matched{$nodes[$i - 1]} || $verified{$nodes[$i - 1]}\n";
					print STDERR "next is $nodes[$i + 1] which is $matched{$nodes[$i + 1]} || $verified{$nodes[$i + 1]}\n";
}
				}
			}
		}
	}
}

for $way (keys(%nodes)) {
	@nodes = @{$nodes{$way}};
	@tlids = @{$tlids{$way}};

	TLID:
	for $tlid (@tlids) {
		for $county (@counties) {
			@tlat = @{$oldlat{$county}{$tlid}};
			@tlon = @{$oldlon{$county}{$tlid}};

			@nlat = @{$newlat{$county}{$tlid}};
			@nlon = @{$newlon{$county}{$tlid}};

			next if $#tlat < 1 || $#nlat < 1;

			for ($pass = 0; $pass < 2; $pass++) {
				$found = -1;
				OUTER:
				for ($i = 0; $i <= $#nodes; $i++) {
					next unless $matched{$nodes[$i]} && $matched{$nodes[$i + $#tlat]};

					for ($j = 0; $j <= $#tlat; $j++) {
						$latd = abs($nodelat{$nodes[$i + $j]} - $tlat[$j]);
						$lond = abs($nodelon{$nodes[$i + $j]} - $tlon[$j]) * $rat;

						next OUTER if $latd * $latd + $lond * $lond > $matchslop2;
					}

					$found = $i;
					last OUTER;
				}

				if ($found != -1) {
					for ($i = 1; $i <= $tlat - 1; $i++) {
						if ($noderefs{$nodes[$found + $i]} != 1) {
							print STDERR "Intermediate node $nodes[$found + $i] referenced by ";
							print STDERR "$noderefs{$nodes[$found + $i]} ways\n";

							next TLID;
						}
					}

					$tlidseen{$county}{$tlid} = 1;

					if ($#tlat == $#nlat) {
						for ($i = 0; $i <= $#tlat; $i++) {
							$newnodelat{$nodes[$found + $i]} = $nlat[$i];
							$newnodelon{$nodes[$found + $i]} = $nlon[$i];

							$latd = abs($nodelat{$nodes[$found + $i]} - $newnodelat{$nodes[$found + $i]});
							$lond = abs($nodelon{$nodes[$found + $i]} - $newnodelon{$nodes[$found + $i]}) * $rat;

							if ($latd * $latd + $lond * $lond > $moveslop2) {
								$moved{$nodes[$found + $i]} = 1;
							}
						}
					} elsif ($#tlat > $#nlat) {
						# Use as many old nodes as necessary - 1 for new positions

						for ($i = 0; $i <= $#nlat - 1; $i++) {
							$newnodelat{$nodes[$found + $i]} = $nlat[$i];
							$newnodelon{$nodes[$found + $i]} = $nlon[$i];
							$moved{$nodes[$found + $i]} = 1;
						}

						# Remove no longer used nodes

						for ($i = $#nlat; $i <= $#tlat - 1; $i++) {
							if ($xml) {
								$newnodelat{$nodes[$found + $i]} = "delete";
								$newnodelon{$nodes[$found + $i]} = "delete";
							} else {
								$newnodelat{$nodes[$found + $i]} = $newnodelat{$nodes[$found + $i - 1]}; 
								$newnodelon{$nodes[$found + $i]} = $newnodelon{$nodes[$found + $i - 1]};
							}

							$moved{$nodes[$found + $i]} = 1;
						}

						# Last old node gets last new position

						$newnodelat{$nodes[$found + $#tlat]} = $nlat[$#nlat];
						$newnodelon{$nodes[$found + $#tlon]} = $nlon[$#nlon];
						$moved{$nodes[$found + $#tlon]} = 1;

						$affected{$way} = 1;
					} else {
						# As many old nodes as available - 1 moved to new positions

						for ($i = 0; $i <= $#tlat - 1; $i++) {
							$newnodelat{$nodes[$found + $i]} = $nlat[$i];
							$newnodelon{$nodes[$found + $i]} = $nlon[$i];
							$moved{$nodes[$found + $i]} = 1;
						}

						# Last node moved to new position

						$newnodelat{$nodes[$found + $#tlat]} = $nlat[$#nlat];
						$newnodelon{$nodes[$found + $#tlon]} = $nlon[$#nlon];
						$moved{$nodes[$found + $#tlon]} = 1;

						# Make new nodes for in between

						for ($i = $#tlat; $i < $#nlat; $i++) {
							$gensym--;

							$newnodelat{$gensym} = $nlat[$i];
							$newnodelon{$gensym} = $nlon[$i];
							$matched{$gensym} = 1;
							$moved{$gensym} = 1;

							$nodelat{$gensym} = $nodelat{$nodes[$found + $i - 1]};
							$nodelon{$gensym} = $nodelon{$nodes[$found + $i - 1]};

							splice @nodes, $found + $i, 0, $gensym;
						}

						$affected{$way} = 1;
					}

					next TLID;
				}

				@tlat = reverse(@tlat);
				@tlon = reverse(@tlon);

				@nlat = reverse(@nlat);
				@nlon = reverse(@nlon);
			}
		}
	}

	@{$nodes{$way}} = @nodes;
}

if (0) {
	# Slight warps to adjacent reality if necessary to preserve consistency

	$again = 1;
	while ($again) {
		$again = 0;

		for $way (keys(%nodes)) {
			@nodes = @{$nodes{$way}};

			{
				for ($i = 0; $i <= $#nodes - 2; $i++) {
					if ($moved{$nodes[$i]} && !$moved{$nodes[$i + 1]}) {
						for ($j = $i + 1; $j <= $#nodes; $j++) {
							last if $moved{$nodes[$j]};
						}

						next if !$moved{$nodes[$j]};
						next if $nodelat{$nodes[$j]} == 0;

						#print STDERR "an adjacent block in $way is $nodes[$i] to $nodes[$j]:  ";
						#print STDERR "$nodelat{$nodes[$i]},$nodelon{$nodes[$i]} to ";
						#print STDERR "$nodelat{$nodes[$j]},$nodelon{$nodes[$j]}\n";

						$olati = $nodelat{$nodes[$i]};
						$oloni = $nodelon{$nodes[$i]};

						$olatj = $nodelat{$nodes[$j]};
						$olonj = $nodelon{$nodes[$j]};

						$olatd = $olati - $olatj;
						$olond = ($oloni - $olonj) * $rat;
						$oang = atan2($olatd, $olond);
						$odist = sqrt($olatd * $olatd + $olond * $olond);

						next if ($odist == 0);

						$nlati = $newnodelat{$nodes[$i]};
						$nloni = $newnodelon{$nodes[$i]};

						$nlatj = $newnodelat{$nodes[$j]};
						$nlonj = $newnodelon{$nodes[$j]};

						$nlatd = $nlati - $nlatj;
						$nlond = ($nloni - $nlonj) * $rat;
						$nang = atan2($olatd, $olond);
						$ndist = sqrt($nlatd * $nlatd + $nlond * $nlond);

						#printf STDERR ("former angle %f dist %f\n", $oang * 180 / $pi, $odist);
						#printf STDERR ("new angle %f dist %f\n", $nang * 180 / $pi, $ndist);

						for ($p = $i + 1; $p < $j; $p++) {
							$plat = $nodelat{$nodes[$p]};
							$plon = $nodelon{$nodes[$p]};

							$platd = $plat - $olatj;
							$plond = ($plon - $olonj) * $rat;
							$pang = atan2($platd, $plond);
							$pdist = sqrt($platd * $platd + $plond * $plond);

							#print STDERR ("intermediate $nodes[$p] $plat $plon ");
							#printf STDERR ("angle %f dist %f\n", $pang * 180 / $pi, $pdist);

							$pdist *= $ndist/$odist;
							$pang += $nang - $oang;

							$plat = $nlatj + $pdist * sin($pang);
							$plon = $nlonj + $pdist * cos($pang) / $rat;

							#print STDERR ("for new pos $plat $plon ");
							#printf STDERR ("replace with angle %f dist %f\n", $pang * 180 / $pi, $pdist);

							$newnodelat{$nodes[$p]} = $plat;
							$newnodelon{$nodes[$p]} = $plon;
							$matched{$nodes[$p]} = 1;
							$moved{$nodes[$p]} = 1;

							$again = 1;
						}
					}
				}

				@nodes = reverse(@nodes);
			}
		}
	}
}

if (0) {
	for $way (keys(%nodes)) {
		@nodes = @{$nodes{$way}};

		for ($i = 1; $i < $#nodes; $i++) {
			if ($moved{$nodes[$i]} && !$matched{$nodes[$i - 1]}) {
				$transitional{$nodes[$i]} = 1;
			}

			if ($moved{$nodes[$i]} && !$matched{$nodes[$i + 1]}) {
				$transitional{$nodes[$i]} = 1;
			}
		}
	}

	for $node (keys(%transitional)) {
		$newnodelat{$node} = ($nodelat{$node} + $newnodelat{$node}) / 2;
		$newnodelon{$node} = ($nodelon{$node} + $newnodelon{$node}) / 2;
	}
}

sub quote {
	$_ = @_[0];

	s/&/&amp;/g;
	s/</&lt;/g;
	s/>/&gt;/g;
	s/"/&quot;/g;

	return $_;
}

sub handle_start2 {
	my ($expat, $element, @tags) = @_;
	my %tags = @tags;

	if ($element eq "node") {
		if ($newnodelat{$tags{'id'}} eq "delete") {
			print "\t<delete>\n";
			print "\t\t<node";

			for $tag (keys(%tags)) {
				print " $tag=\"" . quote($tags{$tag}) . "\"";
			}

			print ">\n";
			$moved{$id} = 0;

			$section = "delete";
			$printtags = 0;
		} elsif ($moved{$tags{'id'}}) {
			$tags{'lat'} = $newnodelat{$tags{'id'}};
			$tags{'lon'} = $newnodelon{$tags{'id'}};
			delete $tags{'changeset'};
			delete $tags{'user'};
			delete $tags{'uid'};
			$tags{'version'} = $tags{'version'} + 1;
			$tags{'timestamp'} = $timestamp;

			print "\t<modify>\n";
			print "\t\t<node";

			for $tag (keys(%tags)) {
				print " $tag=\"" . quote($tags{$tag}) . "\"";
			}

			print ">\n";

			$section = "modify";
			$printtags = 1;
		} else {
			$section = "skip";
			$printtags = 0;
		}
	} elsif ($element eq "way") {
		$way = $tags{'id'};

		if ($affected{$way}) {
			delete $tags{'changeset'};
			delete $tags{'user'};
			delete $tags{'uid'};
			$tags{'version'} = $tags{'version'} + 1;
			$tags{'timestamp'} = $timestamp;

			print "\t<modify>\n";
			print "\t\t<way";

			for $tag (keys(%tags)) {
				print " $tag=\"" . quote($tags{$tag}) . "\"";
			}

			print ">\n";

			@nodes = @{$nodes{$way}};
			for $node (@nodes) {
				if ($newnodelat{$node} ne "delete") {
					print "\t\t\t<nd ref=\"$node\"/>\n";
				}
			}

			$section = "modify";
			$printtags = 1;
		} else {
			$section = "skip";
			$printtags = 0;
		}
	} elsif ($element eq "tag") {
		if ($printtags) {
			$k = quote($tags{'k'});
			$v = quote($tags{'v'});

			print "\t\t\t<tag k=\"$k\" v=\"$v\"/>\n";
		}
	}
}

sub handle_end2 {
	my ($expat, $element) = @_;

	if ($element eq "node" || $element eq "way") {
		if ($section ne "skip") {
			print "\t\t</$element>\n";
			print "\t</$section>\n";
		}

		$section = "skip";
		$printtags = 0;
	}
}

if ($xml) {
	print "\t<create>\n";

	for ($i = $gensym; $i < 0; $i++) {
		print "\t\t<node id=\"$i\" lat=\"$newnodelat{$i}\" lon=\"$newnodelon{$i}\" version=\"1\" timestamp=\"$timestamp\"/>\n";
	}

	print "\t</create>\n";

	$parser = new XML::Parser(Handlers => { Start => \&handle_start2,
						End   => \&handle_end2 });
	$parser->parsefile($tmpfile);

	print "</osmChange>\n";
} else {
	print "1 .5 .5 setrgbcolor\n";

	for $county (@counties) {
		for $tlid (keys(%{$newlat{$county}})) {
			@olat = @{$oldlat{$county}{$tlid}};

			if ($#olat >= 0 && ! $tlidseen{$county}{$tlid}) {
				@a = @{$newlat{$county}{$tlid}};
				@o = @{$newlon{$county}{$tlid}};

				for ($i = 0; $i <= $#a; $i++) {
					printf("%.3f %.3f %s ",
						($o[$i] - $minlon) * 612 / ($maxlon - $minlon),
						($a[$i] - $minlat) * 612 / ($maxlat - $minlat),
						$i == 0 ? "moveto" : "lineto");
				}

				print "stroke\n";
			}
		}
	}

	for $way (keys(%nodes)) {
		@nodes = @{$nodes{$way}};
		@tlids = @{$tlids{$way}};

		if ($#tlids < 0) {
			# New ways, only in OSM

			print ".7 1 .7 setrgbcolor ";

			$within = 0;
			for ($i = 0; $i <= $#nodes; $i++) {
				if ($nodelon{$nodes[$i]} == 0) {
					$within = 0;
				} else {
					printf("%.3f %.3f %s ",
						($nodelon{$nodes[$i]} - $minlon) * 612 / ($maxlon - $minlon),
						($nodelat{$nodes[$i]} - $minlat) * 612 / ($maxlat - $minlat),
						$within ? "lineto" : "moveto");
					$within = 1;
				}
			}

			print "stroke\n";
		} else {
			for ($i = 0; $i < $#nodes; $i++) {
				if (!$matched{$nodes[$i]} && !$matched{$nodes[$i + 1]}) {
					# Not matched, so edited in OSM (or maybe just out of OSM extract bounds)

					if ($nodelat{$nodes[$i]} != 0 && $nodelat{$nodes[$i + 1]} != 0) {
						print "0 .6 0 setrgbcolor ";
						printf("%.3f %.3f moveto %.3f %.3f lineto stroke\n",
							($nodelon{$nodes[$i]} - $minlon) * 612 / ($maxlon - $minlon),
							($nodelat{$nodes[$i]} - $minlat) * 612 / ($maxlat - $minlat),
							($nodelon{$nodes[$i + 1]} - $minlon) * 612 / ($maxlon - $minlon),
							($nodelat{$nodes[$i + 1]} - $minlat) * 612 / ($maxlat - $minlat));
					}
				} else {
					# Old TIGER (either matched and moved, or preserved)

					if ($nodelat{$nodes[$i]} != 0 && $nodelat{$nodes[$i + 1]} != 0) {
						print ".7 .7 1 setrgbcolor ";
						printf("%.3f %.3f moveto %.3f %.3f lineto stroke\n",
							($nodelon{$nodes[$i]} - $minlon) * 612 / ($maxlon - $minlon),
							($nodelat{$nodes[$i]} - $minlat) * 612 / ($maxlat - $minlat),
							($nodelon{$nodes[$i + 1]} - $minlon) * 612 / ($maxlon - $minlon),
							($nodelat{$nodes[$i + 1]} - $minlat) * 612 / ($maxlat - $minlat));
					}

					if ($moved{$nodes[$i]} || $moved{$nodes[$i + 1]}) {
						# One or both ends moved in new TIGER

						print "0 0 .6 setrgbcolor ";

						if ($moved{$nodes[$i]}) {
							$startlat = $newnodelat{$nodes[$i]};
							$startlon = $newnodelon{$nodes[$i]};
						} else {
							$startlat = $nodelat{$nodes[$i]};
							$startlon = $nodelon{$nodes[$i]};
						}

						if ($moved{$nodes[$i + 1]}) {
							$endlat = $newnodelat{$nodes[$i + 1]};
							$endlon = $newnodelon{$nodes[$i + 1]};
						} else {
							$endlat = $nodelat{$nodes[$i + 1]};
							$endlon = $nodelon{$nodes[$i + 1]};
						}

						if ($startlat != 0 && $endlat != 0) {
							printf("%.3f %.3f moveto %.3f %.3f lineto stroke\n",
								($startlon - $minlon) * 612 / ($maxlon - $minlon),
								($startlat - $minlat) * 612 / ($maxlat - $minlat),
								($endlon - $minlon) * 612 / ($maxlon - $minlon),
								($endlat - $minlat) * 612 / ($maxlat - $minlat));
						}
					}
				}
			}
		}
	}
}

unlink($tmpfile);
